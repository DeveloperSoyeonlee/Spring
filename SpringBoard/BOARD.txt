BOARD.txt

CREATE TABLE `springdb`.`tbl_board` (
  `bno` INT NOT NULL AUTO_INCREMENT,
  `title` VARCHAR(200) NOT NULL,
  `content` TEXT NULL,
  `writer` VARCHAR(45) NOT NULL,
  `regdate` TIMESTAMP NOT NULL DEFAULT now(),
  `viewcnt` INT NULL DEFAULT 0,
  PRIMARY KEY (`bno`));

  
  
  * 의존 객체 주입
 
  @Inject 
  	: Java 에서 지원하는 어노테이션 ( = 특정 프레임워크에 종속적이지 않음 = 스프링에서만 사용할 수 있는게 아니다)
 	 
 	 - Q ) 똑같은 객체 이름이 있다면 어떻게 구별해서 가져오는가 ?????
 	   A ) 해당 객체를 찾는 순서
 	 	 [ 타입 -> @Qualifier -> 이름 -> 실패 ]
 	 	 
 	 - @Autowired 와 동일한 동작 수행 But 찾는 순서가 다름
 	 - 빌드도구 (Maven/Gradle)를 통해서 라이브러리 추가가 필요함 (= JUnit 버전12로 올린 이유)
 	 
 	 - 사용가능 위치 : 멤버변수, setter(), 생성자, 일반메서드에서 사용가능
 	 	 
 -----------------------------------------------------------------------------------------------------------
  
  @Autowired
  	: Spring에서 지원하는 어노테이션 
  	
  	- 해당 객체를 찾는 순서
  		[ 타입 -> 이름 -> @Qualifier -> 실패 ]
  		
  	- 프레임워크에 종속되는 상황이다보니까 조금 더 까다롭다
  	- <context:annotation-config/> 라는 xml 설정값 필요 
  		-> Q ) root,sevelet-context,web.xml 에도 없다 근데 왜 쓸 수 있냐 ? 
  		   A ) 스프링의 기본 설정값이므로
  	
  	- 사용가능 위치 : 멤버변수, setter(), 생성자, 일반메서드에서 사용가능 
  
 -----------------------------------------------------------------------------------------------------------
  	
  @Resource
  	: Java 에서 지원하는 어노테이션
  	
  	- 해당 객체를 찾는 순서
		[ 이름 -> 타입 -> @Qualifier -> 실패 ]
  	
  	- <context:annotation-config/> 라는 xml 설정값 필요 
	- 사용가능 위치 : 멤버변수, setter()에서 사용가능 
	- 스프링프레임워크에서 사용하기에 조금 제한적임
  
 -----------------------------------------------------------------------------------------------------------
  
  * @Qualifier 란 무엇인가?
  	
  	- 타입이 동일한 객체(bean)가 여러개 있는 경우 => 스프링컨테이너 초기화 => Exception
  													(확실하게 정보받고있는게 맞는가..?하니까 내부적으로 초기화한번 함)
  	 (@Autowired 동일한 타입에 여러곳 사용)
  	 
  	- 문제상황을 해결하기 위해서 객체의 이름을 지정
	  		(1)
		  		<context:annotation-config>
		  			<bean id="객체명" class="객체주소">
		  				<qulifier value="dao1"/>
		  			</bean>
		  		</context:annotation-config>
		  		
	  		(2) 
			  	 @Inject @Qualifier("Bdao") => 이렇게 별명같은 것을 지정해준다
			  	 private BoardDAO dao;
		  	 
  
  
  
		 * 프로젝트를 함에있어서 체크해야할 부분
		    - 공통주소 URL 를 어떻게 구분하여 정보를 불러올 것인가?
		        - 기존은 멤버형태로 호출해서 할 수 있도록 했다.
		    - 각 기능별 URI를 미리 체크해야한다 (어떻게 매핑할 것인지)
		    - 각 URI별 호출방식(GET/POST)
		    - 결과/페이지 출력
		    - 예외처리
		    - 서비스계층
		    - DAO - SQL 준비
  
  
  * AOP(Aspect Oriented Programming) : 관점지향 프로그래밍
  	- 내가(개발자가) 관심있는 것만 개발하도록 하는 것
  	  개발자가 자신의 역활에만 포커스 맞춰서 개발할 수 있도록 도와주는 것
	  (해야하지만 크게 신경 안쓰는 것들) : 로그, 보안, 트랜젝션 …
  
  	- 메서드 안에서 주기능, 보조기능을 분리해서 필요에 따라서 적용해서 사용하는 방법
  
  
  	* AOP 용어
  	- aspect : 구현하고자 하는 보조기능
	- advice
	 : aspect의 실체 (구현클래스), 메서드 호출 기준으로 여러곳에서 실행할 수 있다
  	- joinpoint
  	 : advice 객체가 적용되는 지점(스프링-메서드 결합점 제공)
  	- pointcut
  	 : advice 객체가 적용되는 대상(패키지명/클래스명/메서드명 형태의 정규식을 사용)
  	 	- 대상을 지정하는 느낌
  	- target
  	 : advice가 적용되는 클래스
  	 	- 얘가 실행이 될 것이라고 체크하는 느낌
  	- weaving : advice를 주기능에 적용하는 것
  	
  	
  
  	* AOP 적용해보기
  	1) target(클래스) 지정하기
  	2) advice(클래스) 지정하기
  	3) 설정파일 사용(xml파일(in스프링) → pointcut을 설정
  	4) 설정파일 - advice 객체와 pointcut을 연결해줄 것(어드바이저)\
  	5) 스프링에서 지원해주는 객체 ProxyFactoryBean 클래스통해 타겟 - 어드바이저 연결
  	6) getBean() 객체 접근 (AOP 적용된 상태의 동작 수행가능)
  	
  
  * 목적

- 필요한 만큼만 정보를 가져오기
- 최대한 빠르게 정보를 가져오기
  
  
  * 페이징처리전 고민해야할 것

	- 페이지 호출 시 페이징처리 여부 판단
	  (ex. list 페이지 .주소호출하게되면 페이징처리가 계산된 형태로 동작되게 함)
	    
	- 페이지 블럭을 통한 페이지 이동
	  (ex. 1,2,3,4,5…)
	    
	- 본문, 수정, 삭제동작에서 목록으로 이동하는 동작
	  (ex. 기존의 페이지를 유지하는 형태의 동작)(3페이지에서 갔다 뒤로갔을때 계속3에머물게)
    
   * 페이징 처리시 지켜야할 점

	- 반드시 GET방식만 사용가능
	
	

	* 페이징 처리시 필요한 정보
	  * 하단부 - 페이지 블럭
	  		ex) 한페이지에 10개씩 출력, 블럭10개 => 총100개글 필요
	  		- 시작페이지 번호 : 1-10, 11-20, 21-30
		  		ex) 한페이지에 10개씩 출력, 블럭10개 => BUT 글이 75개가 있다면?
	  			- 끝페이지 번호 : 1-8(한페이지에 8개가 출력되어야 한다)
	  		
	  		- 끝페이지 번호
	  		
	  		- 전체 데이터 개수 : 전체 글 개수 
	  		
	  		- 이전 : 시작페이지 번호가 1이 아닐 때 존재(1-10일때에는 필요없다)
	  		- 다음 : 마지막 페이지 번호보다 글의 개수가 많을 때 
	  			  
		
			ex) 총 글 : 122, 페이지당 10개씩 출력, 페이지 블럭10개씩 출력
			
			* page 번호 : 3 일 때의 여부
			- 시작페이지 1
			- 끝페이지 10
			- 이전 X 
			- 다음 O
			
			* page 번호 : 10
			- 시작페이지 1
			- 끝페이지 10
			- 이전 X 
			- 다음 O
	
			* page 번호 : 12 일 때의 여부
			- 시작페이지 11
			- 끝페이지 13
			- 이전 O
			- 다음 X
			
			* endPage = (int)(Math.ceil(page/ displayPageNum)) * displayPageNum;
			끝페이지 번호 = (int) (Math.ceil(현재 페이지 / (double) 한 페이지에 출력할 페이지의 수)) * 한 페이지에 출력할 페이지의 수;
			ex) 3페이지 / 10개씩 페이지 출력
						  (int)(Math.ceil(3/10.0) * 10) -> 10// Math.ceil : 소수점 이하를 올림한다.
				23페이지 / 10개씩 페이지 출력
				내가 가진 엔드페이지는 ?? 
						  (int)(Math.ceil(23/10.0) * 10) -> 30
				17페이지 / 5개씩 페이지 출력
				내가 가진 엔드페이지는 ?? 
						  (int)(Math.ceil(17/5.0) * 5) -> 20
	
		
			* startPage = (endPage - displayPageNum) + 1;
			시작 페이지 번호 = (끝페이지 번호 - 한 페이지에 출력할 페이지의 수) + 1
			
			* prev = (startPage == 1)? false : true;
			* next = (endPage * perPageNum >= totalCount)? false : true;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
  
  
  
  
  
  
  
  
  
  
  
  
  